<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Vacation Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    crossorigin=""
  />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"
  />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"
  />
  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      height: 100%;
      display: flex;
      flex-direction: column;
      font-family: Arial, sans-serif;
    }
    #map {
      flex-grow: 1;
      transition: height 0.5s ease;
    }
    #galleryContainer {
      max-height: 250px;
      overflow-y: auto;
      border-top: 1px solid #ccc;
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      padding: 5px;
      background: #fafafa;
      transition: max-height 0.5s ease, padding 0.5s ease;
    }
    #galleryContainer.hidden {
      max-height: 0;
      padding: 0 5px;
      overflow: hidden;
    }
    #galleryContainer img {
      height: 100px;
      cursor: pointer;
      border-radius: 4px;
      object-fit: cover;
    }
    #controls {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 8px;
      z-index: 1000;
      box-shadow: 0 0 5px rgba(0,0,0,0.2);
      font-size: 14px;
    }
    #timeline {
      text-align: center;
      padding: 5px 0;
      font-weight: bold;
      background: #eee;
      font-size: 16px;
    }
    button, input[type="checkbox"] {
      margin: 3px;
    }

    /* Flip the icon horizontally */
    .flipped-icon {
      transform: scaleX(-1);
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div id="controls">
    <label>
      <input type="checkbox" id="toggleCluster" checked /> Use Clustering
    </label>
    <br />
    <label for="yearFilter">Filter Year:</label>
    <select id="yearFilter">
      <option value="">All Years</option>
    </select>
    <br />
    <label>
      <input type="checkbox" id="showPhotosOnTrip" checked />
      Show Photos During Trip
    </label>
    <br />
    <button id="playTripBtn">Play Trip</button>
    <button id="pauseTripBtn" disabled>Pause Trip</button>
    <button id="resetTripBtn">Reset Trip</button>
    <br />
    <label for="speedRange">Speed:</label>
    <input type="range" id="speedRange" min="500" max="5000" step="100" value="1500" />
  </div>

  <div id="timeline"></div>

  <div id="galleryContainer"></div>

  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    crossorigin=""
  ></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>

  <script>
    let map = L.map("map").setView([20, 0], 2);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution:
        '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
    }).addTo(map);

    let clusterGroup = L.markerClusterGroup();
    let plainGroup = L.layerGroup();
    let useClustering = true;

    let gallery = document.getElementById("galleryContainer");
    let yearSet = new Set();

    // Your chosen car icon, flipped horizontally via className
    const carIcon = L.icon({
      iconUrl: "https://cdn-icons-png.flaticon.com/512/744/744465.png",
      iconSize: [32, 32],
      iconAnchor: [16, 16],
      className: "flipped-icon"
    });

    // Variables for trip animation
    let tripPath = [];
    let tripIndex = 0;
    let tripMarker = null;
    let tripTimer = null;
    let tripSpeed = 1500;
    let showPhotosOnTrip = true;

    function formatExifYear(dateStr) {
      if (!dateStr) return null;
      const year = dateStr.split(":")[0];
      if (/^\d{4}$/.test(year)) return year;
      return null;
    }

    function convertToDecimal(coord, ref) {
      if (!coord || !ref) return null;
      let dec = coord[0] + coord[1] / 60 + coord[2] / 3600;
      if (ref === "S" || ref === "W") dec = -dec;
      return dec;
    }

    function clearMarkers() {
      clusterGroup.clearLayers();
      plainGroup.clearLayers();
      if (tripMarker) {
        map.removeLayer(tripMarker);
        tripMarker = null;
      }
      tripPath = [];
      tripIndex = 0;
      document.getElementById("timeline").textContent = "";
      if (window.tripLine) {
        map.removeLayer(window.tripLine);
        window.tripLine = null;
      }
    }

    function loadMarkers(photoFiles, filterYear = null) {
      return new Promise((resolve) => {
        clearMarkers();
        gallery.innerHTML = "";
        yearSet.clear();
        const bounds = [];

        // Helper to track all load promises
        let loadPromises = photoFiles.map((entry) => {
          return new Promise((res) => {
            const file = typeof entry === "string" ? entry : entry.path;
            const caption = typeof entry === "string" ? "" : entry.caption || "";

            const img = new Image();
            img.src = file;
            img.crossOrigin = "anonymous";
            img.onload = () => {
              EXIF.getData(img, function () {
                const lat = EXIF.getTag(this, "GPSLatitude");
                const lng = EXIF.getTag(this, "GPSLongitude");
                const latRef = EXIF.getTag(this, "GPSLatitudeRef");
                const lngRef = EXIF.getTag(this, "GPSLongitudeRef");
                const date = EXIF.getTag(this, "DateTimeOriginal");
                const photoYear = formatExifYear(date);

                if (photoYear) yearSet.add(photoYear);
                if (filterYear && photoYear !== filterYear) {
                  res();
                  return;
                }

                if (lat && lng && latRef && lngRef) {
                  const latitude = convertToDecimal(lat, latRef);
                  const longitude = convertToDecimal(lng, lngRef);

                  if (
                    latitude === null ||
                    longitude === null ||
                    latitude < -90 ||
                    latitude > 90 ||
                    longitude < -180 ||
                    longitude > 180
                  ) {
                    console.warn(
                      `Out-of-range or invalid GPS for ${file}: (${latitude}, ${longitude})`
                    );
                    res();
                    return;
                  }

                  bounds.push([latitude, longitude]);

                  const marker = L.marker([latitude, longitude]);
                  const popupHtml = `
                    <img src="${file}" class="popup-image" style="max-width: 200px; max-height: 150px; display:block; margin-bottom:4px;">
                    <div class="popup-caption">${caption}</div>
                  `;
                  marker.bindPopup(popupHtml);
                  if (useClustering) {
                    clusterGroup.addLayer(marker);
                  } else {
                    plainGroup.addLayer(marker);
                  }

                  // Collect trip path data only if date exists
                  if (date) {
                    tripPath.push({
                      latLng: L.latLng(latitude, longitude),
                      date: date,
                      file: file,
                      caption: caption,
                    });
                  }

                  const gridImg = document.createElement("img");
                  gridImg.src = file;
                  gridImg.alt = caption;
                  gallery.appendChild(gridImg);
                } else {
                  console.log(`No GPS data found for ${file}`);
                }
                res();
              });
            };

            img.onerror = () => {
              // Skip on error but resolve to avoid hanging
              console.warn(`Failed to load image ${file}`);
              res();
            };
          });
        });

        Promise.all(loadPromises).then(() => {
          // Now all images loaded and EXIF read, so sort tripPath
          tripPath.sort((a, b) => new Date(a.date) - new Date(b.date));

          // Draw polyline after sorting
          if (tripPath.length > 1) {
            if (window.tripLine) {
              map.removeLayer(window.tripLine);
            }
            window.tripLine = L.polyline(tripPath.map((p) => p.latLng), {
              color: "blue",
              weight: 3,
              opacity: 0.7,
              smoothFactor: 1,
            }).addTo(map);
          }

          // Fit bounds to all markers
          if (bounds.length) {
            map.fitBounds(bounds);
          }

          // Update year filter dropdown
          const yearSelect = document.getElementById("yearFilter");
          const sortedYears = Array.from(yearSet).sort();
          yearSelect.innerHTML = '<option value="">All Years</option>';
          sortedYears.forEach((y) => {
            const option = document.createElement("option");
            option.value = y;
            option.textContent = y;
            yearSelect.appendChild(option);
          });

          resolve();
        });

        if (useClustering) {
          map.addLayer(clusterGroup);
          map.removeLayer(plainGroup);
        } else {
          map.addLayer(plainGroup);
          map.removeLayer(clusterGroup);
        }
      });
    }

    function updateTimeline(dateStr) {
      const timeline = document.getElementById("timeline");
      timeline.textContent = dateStr ? `Date: ${dateStr}` : "";
    }

    function playTrip() {
      if (tripIndex >= tripPath.length) {
        resetTrip();
        return;
      }

      const step = tripPath[tripIndex];
      if (!tripMarker) {
        tripMarker = L.marker(step.latLng, { icon: carIcon }).addTo(map);
      } else {
        tripMarker.setLatLng(step.latLng);
      }

      map.panTo(step.latLng);

      if (showPhotosOnTrip) {
        tripMarker.bindPopup(`
          <img src="${step.file}" style="max-width: 200px; max-height: 150px; display:block; margin-bottom:4px;">
          <div>${step.caption}</div>
          <div>${step.date}</div>
        `);
        tripMarker.openPopup();
      } else {
        tripMarker.closePopup();
      }

      updateTimeline(step.date);

      tripIndex++;
      tripTimer = setTimeout(playTrip, tripSpeed);
    }

    function pauseTrip() {
      if (tripTimer) {
        clearTimeout(tripTimer);
        tripTimer = null;
      }
      document.getElementById("playTripBtn").disabled = false;
      document.getElementById("pauseTripBtn").disabled = true;
    }

    function resetTrip() {
      pauseTrip();
      tripIndex = 0;
      if (tripMarker) {
        map.removeLayer(tripMarker);
        tripMarker = null;
      }
      updateTimeline("");
      document.getElementById("playTripBtn").disabled = false;
      document.getElementById("pauseTripBtn").disabled = true;
    }

    // Initialize
    let allPhotos = [];

    fetch("photos.json")
      .then((res) => res.json())
      .then(async (photoFiles) => {
        allPhotos = photoFiles;
        await loadMarkers(photoFiles);

        document
          .getElementById("toggleCluster")
          .addEventListener("change", (e) => {
            useClustering = e.target.checked;
            loadMarkers(allPhotos, document.getElementById("yearFilter").value);
          });

        document.getElementById("yearFilter").addEventListener("change", (e) => {
          const selectedYear = e.target.value;
          loadMarkers(allPhotos, selectedYear);
        });

        document
          .getElementById("playTripBtn")
          .addEventListener("click", () => {
            document.getElementById("playTripBtn").disabled = true;
            document.getElementById("pauseTripBtn").disabled = false;
            playTrip();
          });

        document
          .getElementById("pauseTripBtn")
          .addEventListener("click", () => {
            pauseTrip();
          });

        document
          .getElementById("resetTripBtn")
          .addEventListener("click", () => {
            resetTrip();
          });

        document
          .getElementById("showPhotosOnTrip")
          .addEventListener("change", (e) => {
            showPhotosOnTrip = e.target.checked;
          });

        document.getElementById("speedRange").addEventListener("input", (e) => {
          tripSpeed = +e.target.value;
        });
      });
  </script>
</body>
</html>
